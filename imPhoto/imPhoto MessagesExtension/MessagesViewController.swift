//
//  MessagesViewController.swift
//  imUrlData MessagesExtension
//
//  Created by Andrew Dent on 12/1/19.
//  Copyright Â© 2019 Touchgram Pty Ltd. All rights reserved.
//

import UIKit
import os
import Messages
import AVFoundation

class MessagesViewController: MSMessagesAppViewController, UINavigationControllerDelegate, UIImagePickerControllerDelegate {
    
    @IBOutlet fileprivate weak var pickFromRollBtn: UIButton!
    @IBOutlet fileprivate weak var sendBtn: UIButton!
    @IBOutlet fileprivate weak var sendAtchBtn: UIButton!
    @IBOutlet fileprivate weak var imageView: UIImageView!
    @IBOutlet weak var tintView: UIView!
    @IBOutlet weak var buttonStack: UIStackView!
    @IBOutlet weak var imageDetails: UILabel!
    
    var imagePickerController = UIImagePickerController()
    var capturedImages = [UIImage]()
    var attachmentPath : URL? = nil
    var amShowingReceivedPhoto = false  // flag so when we show full window know if should put up picker
    
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view.
        imagePickerController.modalPresentationStyle = .currentContext
        imagePickerController.delegate = self
    }
    
    func showReceivedImage(_ img:UIImage) {
        amShowingReceivedPhoto = true
        imageDetails.isHidden = false
        imageDetails.text = img.debugDescription
        tintView.isHidden = true
        buttonStack.isHidden = true
        imageView.isHidden = false
        imageView.image = img
        sendBtn.isEnabled = false
        sendAtchBtn.isEnabled = false
        pickFromRollBtn.isEnabled = false
    }

    func printDetails(_ msg:MSMessage, from:String) {
        if msg.layout == nil {
            print("\(from) \(msg.debugDescription)\n has no layout")
        }
        else {
            if let lay = msg.layout as? MSMessageTemplateLayout {
                if let im = lay.image {
                    showReceivedImage(im)
                    print("\(from) \(msg.debugDescription)\n with image in layout\n \(im.debugDescription) ")
                } else {
                    print("\(from) \(msg.debugDescription)\n with layout\n \(lay.debugDescription) BUT NO IMAGE")
                }
            } else {
                print("\(from) \(msg.debugDescription)\n has a layout but cannot cast to MSMessageTemplateLayout")
            }
        }
    }

    // MARK: - Conversation Handling
    
    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        // NOTE that means you may have launched the extension to compose a new message OR selected previous, which also hits didSelect
        
        // Use this method to configure the extension and restore previously stored state.
    }
    
    override func didBecomeActive(with conversation: MSConversation) {
        guard let sel = conversation.selectedMessage else {
            os_log("didBecomeActive with no selectedMessage in conversation")
            return
        }
        printDetails(sel, from:"didBecomeActive")
        // nothing to process as image is in the message layout
    }
    
    override func didResignActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dissmises the extension, changes to a different
        // conversation or quits Messages.
        
        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }

    override func didSelect(_ message: MSMessage, conversation: MSConversation) {
        os_log("didSelect")
        printDetails(message, from:"didSelect")
        super.didSelect(message, conversation: conversation)
        // nothing to process as image is in the message layout
    }

    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device. ONLY if the message arrives whilst
        // this extension is active (ie: composing a new message with it)
        // nothing to process as image is in the message layout
        guard let sel = conversation.selectedMessage else {
            os_log("didReceive with no selectedMessage in conversation")
            return
        }
        printDetails(sel, from:"didReceive")
    }
    
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
    }
    
    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.
    
        // Use this to clean up state related to the deleted message.
    }
    
    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
    
        // Use this method to prepare for the change in presentation style.
    }
    
    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
    
        // Use this method to finalize any behaviors associated with the change in presentation style.
        if presentationStyle == .expanded  && !amShowingReceivedPhoto {
            // show the roll if got here by tapping button or just resizing view
            showImagePicker(sourceType: UIImagePickerController.SourceType.photoLibrary)
        }
    }
 
    // MARK: - Comms
    func send() {
        guard let conversation = activeConversation else { fatalError("Expected a conversation") }
        
        let layout = MSMessageTemplateLayout()
        layout.caption = "Your photo from imPhoto sample app"
        let session = conversation.selectedMessage?.session
        let message = MSMessage(session: session ?? MSSession())
        // capturedImages is empty now thanks to end of finishAndUpdate, so use the one from the image
        layout.image = imageView!.image!  // NOTE in this simple example may find this delivers a flipped image
        message.layout = layout  // WARNING do this assignment AFTER the image assigned, it's not referential, structures are copied!
        conversation.insert(message) { (error) in
            if let error = error {
                os_log("Error with MSConversation.insert(message)")
                print(error)
            }
        }
        dismiss()
    }
    
    func sendAttachment() {
        guard let conversation = activeConversation else { fatalError("Expected a conversation") }
        guard
            let imageData = imageView?.image?.jpegData(compressionQuality: 0.8),
            let docUrl = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first
            else {
                dismiss()
                return
        }
        
        attachmentPath = URL(fileURLWithPath: "imPhoto.jpg", relativeTo: docUrl)
        if (try? imageData.write(to: attachmentPath!)) != nil {
            conversation.insertAttachment(attachmentPath!, withAlternateFilename: "imPhoto.jpg") { (error) in
                if let error = error {
                    os_log("Error with insertAttachment(message)")
                    print(error)
                }
            }
        }
        dismiss()
    }

    func sendableDisplay(enabled:Bool) {
        imageView?.isHidden = !enabled
        sendBtn?.isEnabled = enabled
        sendAtchBtn?.isEnabled = enabled
    }
    
    fileprivate func finishAndUpdate() {
        dismiss(animated: true, completion: { [weak self] in
            guard let `self` = self else {
                return
            }
            
            if `self`.capturedImages.count > 0 {
                `self`.sendableDisplay(enabled: true)
                if `self`.capturedImages.count == 1 {
                    // Camera took a single picture.
                    `self`.imageView?.image = `self`.capturedImages[0]
                } else {
                    // Camera took multiple pictures; use the list of images for animation.
                    `self`.imageView?.animationImages = `self`.capturedImages
                    `self`.imageView?.animationDuration = 5    // Show each captured photo for 5 seconds.
                    `self`.imageView?.animationRepeatCount = 0   // Animate forever (show all photos).
                    `self`.imageView?.startAnimating()
                }
                
                // To be ready to start again, clear the captured images array.
                `self`.capturedImages.removeAll()
            }
        })
    }
    

    /// Copied from Apple's PhotoPicker sample
    /// APLViewController.swift
    fileprivate func showImagePicker(sourceType: UIImagePickerController.SourceType) {
        // If the image contains multiple frames, stop animating.
        if (imageView?.isAnimating)! {
            imageView?.stopAnimating()
        }
        if capturedImages.count > 0 {
            capturedImages.removeAll()
        }
        
        imagePickerController.sourceType = sourceType
        imagePickerController.modalPresentationStyle =
            (sourceType == UIImagePickerController.SourceType.camera) ?
                UIModalPresentationStyle.fullScreen : UIModalPresentationStyle.popover
        
        let presentationController = imagePickerController.popoverPresentationController
        /* unlike the PhotoPicker sample, we don't have a UIBarButtonItem
        presentationController?.barButtonItem = button     // Display popover from the UIBarButtonItem as an anchor.
        */
        presentationController?.sourceView = self.view
        let b = self.view.bounds
        presentationController?.sourceRect = b.insetBy(dx: 8.0, dy: 20.0)
        presentationController?.permittedArrowDirections = UIPopoverArrowDirection.any
        /*
        if sourceType == UIImagePickerControllerSourceType.camera {
            // The user wants to use the camera interface. Set up our custom overlay view for the camera.
            imagePickerController.showsCameraControls = false
            
            // Apply our overlay view containing the toolar to take pictures in various ways.
            overlayView?.frame = (imagePickerController.cameraOverlayView?.frame)!
            imagePickerController.cameraOverlayView = overlayView
        }*/
        
        present(imagePickerController, animated: true, completion: {
            // Done presenting.
        })
    }

    // MARK: - Buttons

    @IBAction public func onPickFromRoll(_ sender: UIButton)  {
        if presentationStyle == .compact  {
            amShowingReceivedPhoto = false  // in case still resident, reset the flag
            requestPresentationStyle(.expanded)  // see didTransition(to:)
        } else {
            showImagePicker(sourceType: UIImagePickerController.SourceType.photoLibrary)
        }
    }

    // should only be enabled when there is a backgroundImage set
    @IBAction public func onSend(_ sender: UIButton)  {
        send()
        imageView.image = nil
        sendableDisplay(enabled: false)
    }

    // should only be enabled when there is a backgroundImage set
    @IBAction public func onSendAttachment(_ sender: UIButton)  {
        sendAttachment()
        imageView.image = nil
        sendableDisplay(enabled: false)
    }

    // MARK: - UIImagePickerControllerDelegate
    
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) {
        guard let image = info[UIImagePickerController.InfoKey.originalImage] else { return }
        capturedImages.append(image as! UIImage)
        finishAndUpdate()
        /*
        if !cameraTimer.isValid {
            // Timer is done firing so Finish up until the user stops the timer from taking photos.
            finishAndUpdate()
        }*/
    }
    
    func imagePickerControllerDidCancel(_ picker: UIImagePickerController) {
        dismiss(animated: true, completion: {
            // Done cancel dismiss of image picker.
        })
    }
}
