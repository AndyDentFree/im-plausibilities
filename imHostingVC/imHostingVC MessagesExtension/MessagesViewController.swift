//
//  MessagesViewController.swift
//  imHostingVC MessagesExtension
//
//  Created by Andrew Dent on 12/1/19.
//  Copyright Â© 2019 Touchgram Pty Ltd. All rights reserved.
//

import UIKit
import Messages
import os.log

extension MSMessagesAppPresentationStyle {
    func asChar() -> UInt8 {
        switch self {
        case .compact:
            return UInt8(ascii:"C")
        case .expanded:
            return UInt8(ascii:"E")
        default:
            return UInt8(ascii:"X")
        }
    }
}

class MessagesViewController: MSMessagesAppViewController, HostingVC {

    var receivedItem: UrlSendable? = nil
    let responseKey = "respondingTo"
    static var currentMessagesVC: MessagesViewController? = nil // used so nested screens can call us to navigate

    override func viewDidLoad() {
        super.viewDidLoad()
        MessagesViewController.currentMessagesVC = self
        MessagesViewController.initNavSingleton(with: self)
    }

    override func viewDidDisappear(_ animated: Bool) {
        MessagesViewController.currentMessagesVC = nil
        super.viewDidDisappear(animated)
    }

    // MARK: - Conversation Handling
    func hasIncoming(message: MSMessage?) {
        // Use this method to trigger UI updates in response to the message.
        guard let url = message?.url else { return }
        guard let comps = URLComponents(url: url, resolvingAgainstBaseURL: true) else { return }
        //TODO make more general across UrlSendable
        if let msgMood = comps.queryItems?.first(where: { $0.name == Mood.moodKey })?.value {
            if let parsedMood = Mood(rawValue: msgMood) {
                receivedItem = parsedMood
            }
        }
        if let msgFood = comps.queryItems?.first(where: { $0.name == Food.foodKey })?.value {
            if let parsedFood = Food(rawValue: msgFood) {
                receivedItem = parsedFood
            }
        }
    }

    override func willBecomeActive(with conversation: MSConversation) {
        // Called when the extension is about to move from the inactive to active state.
        // This will happen when the extension is about to present UI.
        // NOTE that means you may have launched the extension to compose a new message OR selected previous, which also hits didSelect

        // Use this method to configure the extension and restore previously stored state.
        os_log("willBecomeActive requesting VC with presentationStyle %C", presentationStyle.asChar())
        hasIncoming(message: conversation.selectedMessage)
        presentViewController(for: conversation, with: self.presentationStyle)
        super.willBecomeActive(with: conversation)
    }


    override func didResignActive(with conversation: MSConversation) {
        os_log("didResignActive")
        super.didResignActive(with:conversation)
        // Called when the extension is about to move from the active to inactive state.
        // This will happen when the user dismisses the extension, changes to a different
        // conversation or quits Messages.

        // Use this method to release shared resources, save user data, invalidate timers,
        // and store enough state information to restore your extension to its current state
        // in case it is terminated later.
    }

    override func didSelect(_ message: MSMessage, conversation: MSConversation) {
        os_log("didSelect %{PUBLIC}s", "\(message.debugDescription)\n URL \(message.url?.absoluteString ?? "no URL")")
        super.didSelect(message, conversation: conversation)
        hasIncoming(message: message)
    }

    override func didReceive(_ message: MSMessage, conversation: MSConversation) {
        // Called when a message arrives that was generated by another instance of this
        // extension on a remote device. ONLY if the message arrives whilst
        // this extension is active (ie: composing a new message with it)
        os_log("didReceive %{PUBLIC}s", "\(message.debugDescription)\n URL \(message.url?.absoluteString ?? "no URL")")
        hasIncoming(message: message)
        super.didReceive(message, conversation: conversation)
    }

    // often a re-activation of the extension
    // note is possible to have multipe messages pushed to bubbles but not sent
    override func didStartSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user taps the send button.
        os_log("didStartSending")
        super.didStartSending(message, conversation:conversation)
    }

    override func didCancelSending(_ message: MSMessage, conversation: MSConversation) {
        // Called when the user deletes the message without sending it.

        // Use this to clean up state related to the deleted message.
    }

    override func didBecomeActive(with conversation: MSConversation) {
        guard let sel = conversation.selectedMessage else {
            os_log("didBecomeActive with no selectedMessage in conversation")
            // valid case most often when start new message or return to editing
            super.didBecomeActive(with:conversation)
            return
        }
        os_log("didBecomeActive %{public}s URL: %{public}s sender:%{public}s conversation: local %s",
                sel.debugDescription,
                (sel.url?.absoluteString ?? "no URL"),
                sel.senderParticipantIdentifier.debugDescription,
                conversation.localParticipantIdentifier.debugDescription)
        super.didBecomeActive(with:conversation)
        navigate(because: .menu)
    }

    override func willResignActive(with conversation: MSConversation) {
        os_log("willResignActive")
        //TODO https://bitbucket.org/touchgram/touchgram4imessage/issues/222/save-current-editing-touchgram-on-quit
        super.willResignActive(with: conversation)
    }

    override func willTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called before the extension transitions to a new presentation style.
        os_log("MessagesVC.willTransition to %C", presentationStyle.asChar())

        super.willTransition(to:presentationStyle)
        presentViewController(for: activeConversation, with: presentationStyle)
    }

    override func didTransition(to presentationStyle: MSMessagesAppPresentationStyle) {
        // Called after the extension transitions to a new presentation style.
        os_log("MessagesVC.didTransition to %C", presentationStyle.asChar())
        super.didTransition(to: presentationStyle)
        // Use this method to finalize any behaviors associated with the change in presentation style.
    }

    // Handles sending because knows activeConversation
    func send(what: UrlSendable) {
        guard let conversation = activeConversation else { fatalError("Expected a conversation when sending") }
        guard var urlComps = URLComponents(string:"data:,") else {
            fatalError("Invalid base URL")
        }
        var qi = [
            URLQueryItem(name: what.key(), value: what.value())
        ]
        if receivedItem != nil {
            qi.append(URLQueryItem(name:responseKey, value:receivedItem!.value()))
        }
        urlComps.queryItems = qi
        let layout = MSMessageTemplateLayout()
        layout.caption = what.value()
        let session = conversation.selectedMessage?.session
        let message = MSMessage(session: session ?? MSSession())
        message.layout = layout
        message.url = urlComps.url
        conversation.insert(message) { (error) in
            if let error = error {
                os_log("Error with MSConversation.insert(message)")
                print(error)
            }
        }
        MessagesViewController.lastReason = .menu  // send implicitly closes so next invocation puts us in menu
        dismiss()
    }

    // note not currently using the conversation but may in future and is standard pattern in Apple sample
    // to pass it into this method
    // BUT
    // as sometimes MessagesViewController.activeConversation is nil, changed to allow nil to be passed in
    func presentViewController(for conversation: MSConversation?, with presentationStyle: MSMessagesAppPresentationStyle){
        os_log("MessagesVC.presentViewController with style %C", presentationStyle.asChar())
        hostVC(makeVC(with: presentationStyle))
    }

}  // class MessagesViewController
